#
#  Usage
# --------
# Python module name:
#   Ruby module name: # import numpy as np => require 'numo/narray'
#
#   order_methods_without_bracket:
#     Python method name: Ruby method name # Case independent of the number of arguments.
#
#   order_methods_without_bracket:
#     Python method name:
#       arg_count_0: Ruby method name # Case without arguments.
#       arg_count_1: Ruby method name # Case with only one argument.
#       arg_count_2: Ruby method name # Case with two arguments.
#
#     e.g. np.array([x1, x2]) => Numo::NArray[x1, x2]
#
#   order_methods_with_bracket:
#     Python method name: Ruby method name # Case independent of the number of arguments.
#
#   order_methods_with_bracket:
#
#     e.g. np.exp(-x) => Numo::NMath.exp(-x)
#
#   order_methods_with_bracket_2_1_x:
#
#     e.g. assertIn(1, [1,2]) => assert_include([1,2], 1)
#
#   reverse_methods:
#
#       arg_count_1: Ruby method name # Case with only one argument.
#         e.g. np.sum(w*x) => (w*x).sum
#       arg_count_2: Ruby method name # Case with two arguments.
#         e.g. heapq.heappush(list, item) => list.push(item)
#
#   range_methods:
#
#     e.g. np.arange(-5.0, 5.0, 0.1) => Numo::DFloat.new(20).seq(-1,0.1)
#
#   methods_map:
#     Python method name:
#       bracket: False            => True: use bracket,  False: not use bracket
#       key: []                   => arguments list
#       main_data_key: 'object'   => Main data key name
#       main_func_key: 'data'     => convert function key name
#       main_func_methodname: ''  => convert function name (default : '')
#       val:                      => arguments dict
#         object: False           => Not use argument data
#         dtype:
#           'None'     : 'Numo::NArray%s%s'
#              => not match case convert to Ruby method (% main_data_key's data, main_func_methodname's data)
#           '%s.int8'  : 'Numo::Int8%s%s'
#              => match case convert to Ruby method (% main_data_key's data, main_func_methodname's data)
#         axis: 'axis'            => Use keyword argument data
#

numpy:
  id: numo/narray # import numpy as np => require 'numo/narray'
  order_methods_without_bracket:
    linspace: 'Numo::DFloat.linspace'
  methods_map:
    array:
      # array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)
      # => Numo::NArray[object]
      # => Numo::Int32[object]
      bracket: False
      key: ['object', 'dtype', 'copy', 'order', 'subok', 'ndmin']
      main_data_key: 'object'                     # Main data
      main_func_key: 'dtype'                      # convert function key name
      main_func_methodname: ''                    # convert function name (default : '')
      val:
        object: False                             # Not use argument data
        dtype: &dtype
          'None':       'Numo::NArray%s%s'       # np.array([5], dtype=np.float32) => Numo::NArray[5]
          '%s.int8':    'Numo::Int8%s%s'
          '%s.int16':   'Numo::Int16%s%s'        # np.array([5], dtype=np.int16) => Numo::Int16[5]
          '%s.int32':   'Numo::Int32%s%s'
          '%s.int64':   'Numo::Int64%s%s'
          '%s.uint8':   'Numo::UInt8%s%s'
          '%s.uint16':  'Numo::UInt16%s%s'
          '%s.uint32':  'Numo::UInt32%s%s'
          '%s.uint64':  'Numo::UInt64%s%s'
          '%s.float32': 'Numo::SFloat%s%s'
          '%s.float64': 'Numo::DFloat%s%s'
          '%s.int':     '%s%s'                   # np.array(x > 0, dtype=np.int) => x > 0
    prod:
      # prod(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue>)
      # => prod(axis: nil, keepdims: false, nan: false)
      #  e.g.
      #    np.prod(shape, axis=1, keepdims=True) => Numo::NArray[shape].prod(axis:1, keepdims:true)
      #    np.prod(shape, axis=0,dtype=np.int32) => Numo::Int32[shape].prod(axis:0)
      bracket: True
      key:
        - 'a'
        - 'axis'
        - 'dtype'
        - 'out'
        - 'keepdims'
      main_data_key: 'a'                          # Main data
      main_func_key: 'dtype'                      # convert function key name
      main_func_methodname: '.prod'               # convert function name
      val:
        a: False                                  # Not use argument data
        axis: 'axis'                              # Use keyword argument data
        dtype: *dtype
        out: False                                # Not use argument data
        keepdims: 'keepdims'                      # Use keyword argument data
    array2string:
      # array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=<built-in function repr>, formatter=None)[source]
      # => format_to_a(separator: ' ')
      bracket: True
      key:
        - 'a'
        - 'max_line_width'
        - 'precision'
        - 'suppress_small'
        - 'separator'
        - 'prefix'
        - 'style'
        - 'formatter'
      main_data_key: 'a'                          # Main data
      main_func: 'format_to_a.join'               # convert function name : np.array2string(x) => x.format_to_a()
      val:
        a: False                                  # Not use argument data
        separator: True                           # Use argument data # np.array2string(x, separator=%s) => x.format_to_a().join(%s)
  order_methods_with_bracket:
    exp: 'Numo::NMath.exp'        # np.exp(-x) => Numo::NMath.exp(-x)
    sin: 'Numo::NMath.sin'
    cos: 'Numo::NMath.cos'
    maximum: 'Numo::NArray.maximum'
  reverse_methods:
    sum: 'sum'                    # np.sum(w*x) => (w*x).sum
  range_methods:
    arange: 'Numo::DFloat.new'    # np.arange(-5.0, 5.0, 0.1) => Numo::DFloat.new(20).seq(-1,0.1)

os:
  id: 
  order_methods_with_bracket:
    path.dirname: 'File.dirname'
    path.basename: 'File.basename'
    path.join: 'File.join'
    walk: 'PyLib.walk'

copy:
  id:
  reverse_methods:
    copy: 'dup'    # copy(foo) => (foo).dup

six:
  id:
  reverse_methods:
    itervalues: 'values'
    iteritems: 'to_a'
  attribute_map:
    PY2: 'false'
    PY3: 'true'
    integer_types: '[Integer]'
  range_map:
    moves.range: ''

functools:
  id:

collections:
  id:
  dict_map:
    OrderedDict: ''

warnings:
  id:
  order_methods_with_bracket:
    warn: 'warn'

weakref:
  id: weakref
  order_methods_with_bracket:
    ref: 'WeakRef.new'

# Provisional implementation.
heapq:
  id:
  reverse_methods:
    heappush:
      arg_count_2: 'push'
    heappop:
      arg_count_1: 'pop'

# Provisional implementation.
traceback:
  id:
  reverse_methods:
    format_list: to_a

unittest:
  id: test/unit
  mod_class_name:
    TestCase: 'Test::Unit::TestCase'
  order_methods_with_bracket_2_1_x:
    TestCase.assertIn: 'assert_include'
    TestCase.assertEqual: 'assert_equal'
  order_methods_with_bracket:
    TestCase.assertTrue: 'assert'
  ignore:
    main: ''

