#
#  Usage
# --------
# Python module name:
#   id: Ruby module name
#     e.g. id: numo/narray # import numpy as np => require 'numo/narray'
#   mod_name: Ruby module namespace
#     e.g. mod_name: Numo  # from numpy import array => require 'numo/narray'; include Numo # mod: mod_name + '::'
#   mod_class_name:
#     Pyth n class name: Ruby class name    # For class inheritance
#     e.g. TestCase: 'Test::Unit::TestCase'
#
#   order_methods_with_bracket:
#     Python method name: Ruby method name # Case independent of the number of arguments.
#     e.g. os.path.dirnam(name) => File.dirname(name)
#
#   reverse_methods:
#     arg_count_1: Ruby method name # Case with only one argument.
#     arg_count_2: Ruby method name # Case with two arguments.
#       e.g. heapq.heappop(list)        => list.pop
#       e.g. heapq.heappush(list, item) => list.push(item)
#
#   methods_map:
#     Python method name:
#       ins_bracket: True          => True: use bracket, False: not use bracket(default) # e.g. (1+5).sum
#       bracket: False             => True: use bracket(default), False: not use bracket # e.g. Numo::NArray[object]
#       key:
#         - ['second']             => argument count 1 (len(key[..]) == 1) case
#         - ['first', 'second'..]  => argument count 2 (len(key[..]) == 2) or not match (key[-1]) case
#       key_order:                 => key order change setting
#         - ['second']             => argument count 1 (len(key_order[..]) == 1) case
#         - ['second', 'first'..]  => argument count 2 (len(key_order[..]) == 2) or not match (key[-1]) case
#       main_data_key: object      => Main data key name
#       main_func_key: dtype       => convert function key name
#       main_func_key_nm: dtype_nm => convert function key name (not match case)
#       main_func_methodname: ''   => convert function (attribute) name (default : '')
#       val:                       => arguments dict
#         object: False            => Not use argument data
#         dtype:
#           'None'     : 'Numo::NArray%s%s'
#              => not match case convert to Ruby method (% main_data_key's data, main_func_methodname's data)
#           '%s.int8'  : 'Numo::Int8%s%s'
#              => match case convert to Ruby method (% main_data_key's data, main_func_methodname's data)
#         axis: axis               => Use keyword argument data
#       rtn:
#         - "%(start)s"            => customize return string (main_func + rtn) : argument count 1 (rtn[0]) case
#         - "%(start)s %(second)s" => customize return string (main_func + rtn) : argument count 2 (rtn[1]) or over (rtn[-1]) case
#
#   ignore:
#     Python method name:          # ignore case
#       e.g.    main: ''
#

numpy:
  id: numo/narray # import numpy as np => require 'numo/narray'
  mod_name: Numo  # from numpy import array => require 'numo/narray'; include Numo # mod: mod_name + '::'
  methods_map:
    array:
      # array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)
      # => Numo::NArray[object]
      # => Numo::Int32[object]
      bracket: False
      key:
        - [object, dtype, copy, order, subok, ndmin]
      main_data_key: object                       # Main data
      main_func_key: dtype                        # convert function key name
      main_func_key_nm: dtype_nm                  # convert function key name (not match case)
      val:
        object: False                             # Not use argument data
        dtype: &dtype
          '%s.int8':    '%(mod)sInt8%(data)s%(name)s'
          '%s.int16':   '%(mod)sInt16%(data)s%(name)s'        # np.array([5], dtype=np.int16) => Numo::Int16[5]
          '%s.int32':   '%(mod)sInt32%(data)s%(name)s'
          '%s.int64':   '%(mod)sInt64%(data)s%(name)s'
          '%s.uint8':   '%(mod)sUInt8%(data)s%(name)s'
          '%s.uint16':  '%(mod)sUInt16%(data)s%(name)s'
          '%s.uint32':  '%(mod)sUInt32%(data)s%(name)s'
          '%s.uint64':  '%(mod)sUInt64%(data)s%(name)s'
          '%s.float32': '%(mod)sSFloat%(data)s%(name)s'
          '%s.float64': '%(mod)sDFloat%(data)s%(name)s'
          '%s.int':     '%(data)s%(name)s'                   # np.array(x > 0, dtype=np.int) => x > 0
        dtype_nm: &dtype_na '%(mod)sNArray%(data)s%(name)s'  # np.array([5], dtype=np.float32) => Numo::NArray[5]
    prod:
      # prod(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue>)
      # => prod(axis: nil, keepdims: false, nan: false)
      #  e.g.
      #    np.prod(shape, axis=1, keepdims=True) => Numo::NArray[shape].prod(axis:1, keepdims:true)
      #    np.prod(shape, axis=0,dtype=np.int32) => Numo::Int32[shape].prod(axis:0)
      key:
        - [a, axis, dtype, out, keepdims]
      main_data_key: a                            # Main data
      main_func_key: dtype                        # convert function key name
      main_func_key_nm: dtype_nm                  # convert function key name (not match case)
      main_func_methodname: '.prod'               # convert function (attribute) name
      val:
        a: False                                  # Not use argument data
        axis: axis                                # Use keyword argument data
        dtype: *dtype
        dtype_nm: *dtype_na
        out: False                                # Not use argument data
        keepdims: keepdims                        # Use keyword argument data
    array2string:
      # array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=<built-in function repr>, formatter=None)[source]
      # => format_to_a(separator: ' ')
      key:
        - [a, max_line_width, precision, suppress_small, separator, prefix, style, formatter]
      main_data_key: a                            # Main data
      main_func: format_to_a.join                 # convert function name : np.array2string(x) => x.format_to_a()
      val:
        a: False                                  # Not use argument data
        separator: True                           # Use argument data # np.array2string(x, separator=%s) => x.format_to_a().join(%s)
    sum:
      # (a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue>)[source]
      key:
        - [a, axis, dtype, out, keepdims]
      val:
        a: False                                  # Not use argument data
      ins_bracket: True
      main_data_key: a                            # Main data
      main_func: ''                               # convert function name : np.sum(w*x) => (w*x).sum
      main_func_methodname: sum                   # convert function (attribute) name
    ndarray:
      bracket: False
      main_func: '%(mod)sNArray'                  # convert function name : np.ndarray => Numo::NArray
    exp:
      # (x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
      main_func: '%(mod)sNMath.exp'               # np.exp(-x) => Numo::NMath.exp(-x)
      key:
        - [x, out, where, casting, order, dtype, subok]
      val:
        x: True
    sin:
      # (x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
      main_func: '%(mod)sNMath.sin'
      key:
        - [x, out, where, casting, order, dtype, subok]
      val:
        x: True
    cos:
      # (x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
      main_func: '%(mod)sNMath.cos'
      key:
        - [x, out, where, casting, order, dtype, subok]
      val:
        x: True
    maximum:
      # (x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
      main_func: '%(mod)sNArray.maximum'
      key:
        - [x1, x2, out, where, casting, same_kind, order, dtype, subok]
      val:
        x1: True
        x2: True
    linspace:
      # (start, stop, num=50, endpoint=True, retstep=False, dtype=None)
      main_func_key: dtype                        # convert function key name
      main_func_key_nm: dtype_nm                  # convert function key name (not match case)
      main_func_methodname: '.linspace'           # convert function (attribute) name
      key:
        - [start, stop, num, endpoint, retstep, dtype]
      val:
        start: True
        stop: True
        num: True
        endpoint : False
        retstep : False
        dtype: *dtype
        dtype_nm: &dtype_df '%(mod)sDFloat%(data)s%(name)s'
    arange:
      # ([start, ]stop, [step, ]dtype=None)
      main_func_key: dtype                        # convert function key name
      main_func_key_nm: dtype_nm                  # convert function key name (not match case)
      key:
        - [stop]                                  # argument count 1 case
        - [start, stop, step, dtype]              # argument count 2 or over (not 1) case
      val:
        start: True
        stop: True
        step: True
        dtype: *dtype
        dtype_nm: *dtype_df
      rtn:
        # <Python> np.arange(6)
        # <Ruby>   Numo::DFloat.new(6).seq(0)
        #          => [0, 1, 2, 3, 4, 5]
        - ".new(%(stop)s).seq(0)"
        # <Python> np.arange(1,6) # s:start, e:stop
        # <Ruby>   Numo::DFloat.new(6-1).seq(1)
        #          => [1, 2, 3, 4, 5]
        - ".new(%(stop)s-(%(start)s)).seq(%(start)s)"
        # <Python> np.arange(1,6,2) # s:start, e:stop, t:step
        # <Ruby>   Numo::DFloat.new(((6-1)/2.to_f).ceil).seq(1, 2)
        #          =>[1, 3, 5]
        - ".new(((%(stop)s-(%(start)s))/(%(step)s).to_f).ceil).seq(%(start)s, %(step)s)"

os:
  id: 
  order_methods_with_bracket:
    path.dirname: 'File.dirname'
    path.basename: 'File.basename'
    path.join: 'File.join'
    walk: 'PyLib.walk'

copy:
  id:
  reverse_methods:
    copy: 'dup'    # copy(foo) => (foo).dup

six:
  id:
  reverse_methods:
    itervalues: 'values'
    iteritems: 'to_a'
  attribute_map:
    PY2: 'false'
    PY3: 'true'
    integer_types: '[Integer]'
  range_map:
    moves.range: ''

functools:
  id:

collections:
  id:
  dict_map:
    OrderedDict: ''

warnings:
  id:
  order_methods_with_bracket:
    warn: 'warn'

weakref:
  id: weakref
  order_methods_with_bracket:
    ref: 'WeakRef.new'

# Provisional implementation.
heapq:
  id:
  reverse_methods:
    heappush:
      arg_count_2: 'push'
    heappop:
      arg_count_1: 'pop'

# Provisional implementation.
traceback:
  id:
  reverse_methods:
    format_list: to_a

unittest:
  id: test/unit
  mod_name: Test::Unit
  mod_class_name:
    TestCase: 'Test::Unit::TestCase'
  methods_map:
    TestCase.assertIn:
      # (first, second, msg=None)
      main_func: 'assert_include'
      key:
        - [first, second, msg]
      key_order:
        # <Python> self.assertIn('foo', ['foo', 'bar'], 'message test')
        # <Ruby>   assert_include(['foo', 'bar'],'foo','message test')
        - [second, first, msg]
      val:
        first: True
        second: True
        msg: True
    TestCase.assertEqual:
      # (first, second, msg=None)
      main_func: 'assert_equal'
      key:
        - [first, second, msg]
      key_order:
        - [second, first, msg]
      val:
        first: True
        second: True
        msg: True
    TestCase.assertTrue:
      # (expr, msg=None)
      main_func: 'assert'
      key:
        - [expr, msg]
      val:
        expr: True
        msg: True
  ignore:
    main: ''

