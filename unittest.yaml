#
#  Usage
# --------
# Python module name:
#   id: Ruby module name
#     e.g. id: numo/narray # import numpy as np => require 'numo/narray'
#   mod_name: Ruby module namespace
#     e.g. mod_name: Numo  # from numpy import array => require 'numo/narray'; include Numo # mod: mod_name + '::'
#   mod_class_name:
#     Pyth n class name: Ruby class name    # For class inheritance
#     e.g. TestCase: 'Test::Unit::TestCase'
#
#   methods_map:
#     Python method name:
#       ins_bracket: True          => True: use bracket, False: not use bracket(default) # e.g. (1+5).sum
#       bracket: False             => True: use bracket(default), False: not use bracket # e.g. Numo::NArray[object]
#       key:
#         - ['second']             => argument count 1 (len(key[..]) == 1) case
#         - ['first', 'second'..]  => argument count 2 (len(key[..]) == 2) or not match (key[-1]) case
#       key_order:                 => key order change setting
#         - ['second']             => argument count 1 (len(key_order[..]) == 1) case
#         - ['second', 'first'..]  => argument count 2 (len(key_order[..]) == 2) or not match (key[-1]) case
#       main_data_key: object      => Main data key name
#       main_func_key: dtype       => convert function key name
#       main_func_key_nm: dtype_nm => convert function key name (not match case)
#       main_func_methodname: ''   => convert function (attribute) name (default : '')
#       val:                       => arguments dict
#         object: False            => Not use argument data
#         dtype:
#           'None'     : 'Numo::NArray%s%s'
#              => not match case convert to Ruby method (% main_data_key's data, main_func_methodname's data)
#           '%s.int8'  : 'Numo::Int8%s%s'
#              => match case convert to Ruby method (% main_data_key's data, main_func_methodname's data)
#         axis: axis               => Use keyword argument data
#       rtn:
#         - "%(start)s"            => customize return string (main_func + rtn) : argument count 1 (rtn[0]) case
#         - "%(start)s %(second)s" => customize return string (main_func + rtn) : argument count 2 (rtn[1]) or over (rtn[-1]) case
#
#   ignore:
#     Python method name:          # ignore case
#       e.g.    main: ''
#

unittest:
  id: test/unit
  mod_name: Test::Unit
  mod_class_name:
    TestCase: 'Test::Unit::TestCase'
  methods_map:
    TestCase.assertIn:
      # (first, second, msg=None)
      main_func: 'assert_include'
      key:
        - [first, second, msg]
      key_order:
        # <Python> self.assertIn('foo', ['foo', 'bar'], 'message test')
        # <Ruby>   assert_include(['foo', 'bar'],'foo','message test')
        - [second, first, msg]
      val:
        first: True
        second: True
        msg: True
    TestCase.assertEqual:
      # (first, second, msg=None)
      main_func: 'assert_equal'
      key:
        - [first, second, msg]
      key_order:
        - [second, first, msg]
      val:
        first: True
        second: True
        msg: True
    TestCase.assertTrue:
      # (expr, msg=None)
      main_func: 'assert'
      key:
        - [expr, msg]
      val:
        expr: True
        msg: True
  ignore:
    main: ''

